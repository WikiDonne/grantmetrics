<?php
/**
 * This file contains only the EventDataController class.
 */

namespace AppBundle\Controller;

use AppBundle\Model\Event;
use AppBundle\Model\Job;
use AppBundle\Model\Program;
use AppBundle\Service\JobHandler;
use Doctrine\ORM\EntityManager;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

/**
 * The EventDataController handles the event data page, export options,
 * and statistics generation.
 */
class EventDataController extends Controller
{
    /**********************
     * BROWSING REVISIONS *
     **********************/

    /**
     * Lists individual revisions that make up the Event.
     * @Route("/programs/{programTitle}/{title}/revisions", name="Revisions")
     * @Route("/programs/{programTitle}/{title}/revisions/", name="RevisionsSlash")
     * @param Request $request The request object generated by Symfony.
     * @param string $programTitle Title of the program.
     * @param string $title Title of the event.
     * @return Response
     */
    public function revisionsAction(Request $request, $programTitle, $title)
    {
        $em = $this->container->get('doctrine')->getManager();
        $program = $em->getRepository(Program::class)
            ->findOneBy(['title' => $programTitle]);
        $eventRepo = $em->getRepository(Event::class);
        $eventRepo->setContainer($this->container);
        $event = $eventRepo->findOneBy([
                'program' => $program,
                'title' => $title,
            ]);

        $offset = (int)$request->query->get('offset');
        $limit = 50;

        return $this->render('events/revisions.html.twig', [
            'gmTitle' => $event->getDisplayTitle(),
            'program' => $program,
            'event' => $event,
            'revisions' => $eventRepo->getRevisions($event, $offset * $limit, $limit),
            'numRevisions' => $eventRepo->getNumRevisions($event),
            'numResultsPerPage' => $limit,
            'offset' => $offset,
        ]);
    }

    /*************************
     * GENERATING STATISTICS *
     *************************/

    /**
     * Endpoint to create a Job to calculate and store statistics for the event.
     * If there is quota, the job will be ran immediately and the results returned as JSON.
     * Otherwise, a job is created and it will later be ran via cron.
     * @Route("/events/process/{eventId}", name="EventProcess", requirements={"id" = "\d+"})
     * @Route("/events/process/{eventId}/", name="EventProcessSlash", requirements={"id" = "\d+"})
     * @param JobHandler $jobHandler The job handler service, provided by Symfony dependency injection.
     * @param Request $request The request object generated by Symfony.
     * @param int $eventId The ID of the event to process.
     * @return JsonResponse
     * Coverage done on the ProcessEventCommand itself to avoid overhead of the request stack,
     * and also because this action can only be called via AJAX.
     */
    public function generateStatsAction(JobHandler $jobHandler, Request $request, $eventId)
    {
        // Only responsd to AJAX.
        if (!$request->isXmlHttpRequest()) {
            throw new AccessDeniedHttpException();
        }

        $em = $this->container->get('doctrine')->getManager();

        // Find the Event.
        $event = $em->getRepository(Event::class)
            ->findOneBy(['id' => $eventId]);

        if ($event === null) {
            throw new NotFoundHttpException();
        }

        // Check if a Job already exists. This is difficult to test, so we'll ignore...
        // @codeCoverageIgnoreStart
        if ($event->hasJob()) {
            $job = $event->getJobs()[0];

            return new JsonResponse(
                [
                    'error' => 'A job with ID '.$job->getId().' already exists'.
                        ' for the event: '.$event->getDisplayTitle(),
                    'status' => $job->getStarted() ? 'running' : 'queued',
                ],
                Response::HTTP_ACCEPTED
            );
        }
        // @codeCoverageIgnoreEnd

        return $this->createJobAndGetResponse($jobHandler, $em, $event);
    }

    /**
     * Create a Job for the given Event, and return the JSON response.
     * @param  JobHandler $jobHandler The job handler service.
     * @param  EntityManager $em The Doctrine EntityManager.
     * @param  Event $event
     * @return JsonResponse
     * Coverage done on the ProcessEventCommand itself to avoid overhead of the request stack,
     * and also because this action can only be called via AJAX.
     * @codeCoverageIgnore
     */
    private function createJobAndGetResponse(JobHandler $jobHandler, EntityManager $em, Event $event)
    {
        // Create a new Job for the Event, and flush to the database.
        $job = new Job($event);
        $em->persist($job);
        $em->flush();

        $stats = $jobHandler->spawn($job);

        if (is_array($stats)) {
            return new JsonResponse(
                [
                    'success' => 'Statistics for event '.$event->getId().
                        ' successfully generated.',
                    'status' => 'complete',
                    'data' => $stats,
                ],
                Response::HTTP_OK
            );
        }

        return new JsonResponse(
            [
                'success' => 'Job has successfully been queued.',
                'status' => 'queued',
            ],
            Response::HTTP_ACCEPTED
        );
    }
}
